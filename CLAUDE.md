# APISCAN - API Endpoint Scanner

## Project Overview
**apiscan** is a CLI application that extracts API endpoints from various implementation types and generates OpenAPI documentation.

## Core Requirements

### Goal
- Create OpenAPI file in JSON or YAML format (✅ **ALWAYS GENERATED BY DEFAULT**)
- Output summary report - informative to users

### Critical Design Constraints
- **NO COMPILATION/BUILD REQUIRED**: The input project to be analyzed should NOT be built or compiled. Many enterprise projects cannot be compiled due to dependencies, configurations, or access restrictions. The tool MUST analyze source code as-is by reading files directly.
- CLI application
- Enterprise grade quality

### Design Considerations
- Extensible to analyze other frameworks (Quarkus, Struts) and languages (.NET Core)
- Testable architecture
- Easy to maintain
- Best performance
- AST-based implementation for accurate extraction

### MVP Scope
- Java-based API implementations
- Spring MVC support
- Spring Boot support

### Test Projects
- `C:\Users\Rudi Kristanto\prj\spring-petclinic-rest`
- `C:\Users\Rudi Kristanto\prj\shopizer`

## Development Guidelines
1. Always analyze source code without compilation
2. Use AST parsing for accurate endpoint extraction
3. Focus on extensibility for future framework support
4. Maintain clear separation between framework-specific analyzers

## Key Features

### Interface-Based Endpoint Detection
The Spring framework scanner supports multiple approaches for API endpoint detection:

1. **Direct Annotation Scanning**: Extracts endpoints from controller classes with Spring mapping annotations (`@GetMapping`, `@PostMapping`, etc.)

2. **Interface Implementation Analysis**: When controllers implement API interfaces (common in generated code or contract-first development), the scanner:
   - Collects all interfaces with Spring mapping annotations in a first pass
   - Matches controller classes that implement these interfaces
   - Extracts endpoint definitions from the interface methods

3. **Method Inference**: For cases where interface definitions are not available (external dependencies, generated code), the scanner can infer API endpoints from controller methods marked with `@Override`:
   - Analyzes method names to determine HTTP methods (`listOwners` → GET, `addOwner` → POST, `updateOwner` → PUT, `deleteOwner` → DELETE)
   - Constructs RESTful paths based on method names and parameters (`getOwner(Integer ownerId)` → `/owners/{ownerId}`)
   - Supports nested resource patterns (`addPetToOwner` → `/owners/{ownerId}/pets`)

### Test Results
- **spring-petclinic-rest**: Successfully detected 35 endpoints across 8 controllers
- **Before improvement**: 1 endpoint detected
- **After improvement**: 35 endpoints detected (35x improvement)

### Supported Patterns
- Standard REST controllers with direct annotations
- Interface-based API definitions (OpenAPI generated, contract-first)
- Mixed patterns within the same project
- Nested resource relationships (owners/pets/visits)
- All standard HTTP methods (GET, POST, PUT, DELETE, PATCH)

## Test Coverage

### Comprehensive Test Suite
The APISCAN tool includes extensive test coverage for all major enterprise Spring Java application scenarios:

#### Core Component Tests
- **JavaSourceParserTest**: AST parsing functionality, file handling, error scenarios
- **ApiEndpointTest**: Data model validation, parameter handling, request/response structures

#### Enterprise API Pattern Tests
1. **Direct Annotation-Based APIs**
   - Controllers with Spring mapping annotations (`@GetMapping`, `@PostMapping`, etc.)
   - Standard RESTful CRUD operations
   - Path parameter and request body handling
   - Example: `@RestController` with `@RequestMapping("/api/users")`

2. **Interface-Based APIs with Available Definitions**
   - Controllers implementing interfaces that contain Spring annotations
   - Contract-first development patterns
   - OpenAPI code generation scenarios
   - Example: `ProductController implements ProductsApi` where `ProductsApi` has annotations

3. **Interface-Based APIs with Missing Definitions (@Override Inference)**
   - Controllers implementing external interfaces (JAR dependencies, generated code)
   - Intelligent endpoint inference from method names and parameters
   - Method pattern recognition (`listOrders` → GET, `addOrder` → POST, `deleteOrder` → DELETE)
   - Path construction from method signatures (`getOrder(Integer orderId)` → `/orders/{orderId}`)
   - Example: Real-world scenario like spring-petclinic-rest project

4. **Mixed Implementation Scenarios**
   - Projects combining both direct annotation and interface-based controllers
   - Multiple architectural patterns within the same codebase
   - Different teams using different approaches

5. **Complex Nested Resource Hierarchies**
   - Multi-level REST resource relationships
   - Enterprise-grade resource structures
   - Examples: 
     - `companies/{id}/departments/{id}/employees/{id}/projects`
     - `owners/{id}/pets/{id}/visits`
   - Intelligent nested path inference from method names

6. **HTTP Method and Annotation Variations**
   - `@RequestMapping` with method parameters
   - Specialized annotations (`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, `@PatchMapping`)
   - Parameter annotations (`@PathVariable`, `@RequestParam`, `@RequestBody`, `@RequestHeader`)
   - Security annotations (`@PreAuthorize`) - handled gracefully

7. **CLI Integration Testing**
   - End-to-end command-line interface testing
   - Output format validation (JSON/YAML)
   - Error handling and edge cases
   - Real project scanning verification

#### Test Scenarios Covering Enterprise Requirements

**Scenario 1: Legacy Enterprise Application**
- Mixed direct annotations and interface implementations
- Complex business domain models
- Multi-module Maven projects
- Security-enabled endpoints

**Scenario 2: Microservices Architecture**
- Contract-first API development
- Generated client/server stubs
- Interface definitions in separate modules
- Cross-service communication patterns

**Scenario 3: Code Generation Workflows**
- OpenAPI specification → Java code generation
- Missing interface source code (JAR dependencies)
- Method signature-based endpoint inference
- Automated documentation generation

**Scenario 4: Migration Projects**
- Gradual migration from older frameworks
- Mixed annotation styles within controllers
- Backward compatibility requirements
- Documentation catch-up scenarios

**Scenario 5: Enterprise Integration**
- Complex nested resource hierarchies
- Business entity relationships
- Multi-level authorization patterns
- Comprehensive API documentation needs

### Test Execution and Quality Assurance
- **Maven Integration**: Tests run as part of build process (`mvn test`)
- **Java 17 Compatibility**: Modern language features with text blocks
- **Flexible Assertions**: Robust test expectations that accommodate inference variations
- **Performance Testing**: Large project scanning (spring-petclinic-rest: 35 endpoints)
- **Error Handling**: Malformed code, missing dependencies, parsing failures
- **Output Validation**: Generated OpenAPI specifications, CLI reports

### Continuous Quality Metrics
- **Code Coverage**: Core parsing, framework detection, endpoint extraction
- **Real-world Validation**: Tested against production Spring projects
- **Regression Testing**: Ensures existing functionality remains intact
- **Edge Case Handling**: Unusual method names, complex generics, annotation variations

## Enhanced User Experience

### Professional CLI Output Formatting
The APISCAN tool now features enterprise-grade console output with improved readability and professional presentation:

#### Key Improvements
1. **Professional Header Design**: Clean ASCII formatting and clear branding (Windows-compatible)
   ```
   =========================================================
   |                   APISCAN v1.0.0                     |
   |            Enterprise API Endpoint Scanner           |
   =========================================================
   ```

2. **Clean Progress Indicators**: Clear status messages without verbose debug output
   - Framework detection confirmation
   - Scan progress with timing information
   - Endpoint discovery count
   - OpenAPI generation status

3. **Structured Summary Reports**: Professionally formatted scan results
   - **Project Information**: Clean project name extraction and framework details
   - **Performance Metrics**: File scan counts and duration with proper number formatting
   - **HTTP Method Breakdown**: Tabulated endpoint counts by method with icons
   - **Controller Organization**: Sorted by endpoint count, easy to identify high-traffic controllers
   - **Detailed Endpoint Listing**: Organized by controller with hierarchical display

4. **Enhanced Data Visualization**:
   - **HTTP Method Indicators**: [GET], [POST], [PUT], [DEL], [PATCH]
   - **ASCII-Safe Formatting**: Cross-platform compatible console output
   - **Parameter Display**: Compact parameter information without clutter
   - **Deprecation Indicators**: Clear [DEPRECATED] marking of deprecated endpoints

5. **Reduced Debug Noise**: 
   - **Production Logging**: Debug information sent to log files, not console
   - **Clean Console Output**: Only essential information displayed to users
   - **Verbose Mode Available**: Full details accessible with `-v` flag when needed

#### Example Professional Output
```
[INFO] Framework detected: Spring
[INFO] Scanning for API endpoints...
[SUCCESS] Scan completed in 1,266ms
[RESULT] Found 35 API endpoints

=========================================================
|                    SCAN SUMMARY                      |
=========================================================
Project:          spring-petclinic-rest
Framework:        Spring  
Files scanned:    83
Duration:         1,266 ms
Total endpoints:  35

HTTP Methods:
-----------------------------------------
  [DEL] DELETE   6 endpoints
  [GET] GET      14 endpoints
  [POST] POST     8 endpoints
  [PUT] PUT      7 endpoints

Controllers:
-----------------------------------------
  [ 9] OwnerRestController
  [ 5] SpecialtyRestController
  [ 5] VetRestController
  [ 5] PetTypeRestController
  [ 5] VisitRestController
  [ 4] PetRestController
  [ 1] UserRestController
  [ 1] RootRestController

=========================================================
|             SCAN COMPLETED SUCCESSFULLY!             |
=========================================================
```

### Output Format Testing
Comprehensive test coverage for the enhanced output formatting:
- **ReportGeneratorTest**: Complete test suite validating all formatting improvements
- **ASCII-Safe Presentation**: Verification of cross-platform compatible formatting
- **Content Organization**: Testing of tabular layouts and hierarchical displays  
- **Edge Case Handling**: Long controller names, empty results, error scenarios
- **Console Output Capture**: Systematic validation of all output sections

### Cross-Platform Compatibility
The enhanced output formatting addresses common Windows console encoding issues:
- **ASCII-Safe Characters**: Replaced Unicode box-drawing and emoji with standard ASCII
- **Windows Console Support**: Fully compatible with Windows Command Prompt and PowerShell
- **Universal Display**: Consistent appearance across Windows, macOS, and Linux terminals
- **Character Encoding Independent**: No dependency on UTF-8 console support
- **Professional Appearance**: Maintains enterprise-grade visual quality with standard characters

### User Experience Benefits
1. **Professional Appearance**: Enterprise-grade console output suitable for business presentations
2. **Information Density**: Maximum useful information in minimal screen space
3. **Quick Scanning**: Easy to identify key metrics and problem areas at a glance
4. **Consistent Formatting**: Standardized presentation across all scan results
5. **Reduced Cognitive Load**: Clean, organized information hierarchy
6. **Tool Credibility**: Professional appearance enhances user trust and adoption

## OpenAPI File Generation

### Core Functionality Alignment
APISCAN now properly fulfills its primary goal from the Core Requirements - **creating OpenAPI files by default**:

#### Default Behavior (Fixed)
- **Automatic Generation**: OpenAPI files are **always generated** when scanning a project
- **Smart File Naming**: Auto-generates filename as `{project-name}-openapi.{format}` in current directory
- **Format Support**: YAML (default) and JSON formats available with `-f/--format` flag
- **User-Friendly**: No need to remember `-o/--output` parameter for basic usage

#### File Location
- **Default Location**: Generated in the current working directory (where you run APISCAN)
- **Custom Location**: Use `-o/--output` to specify alternative file path
- **Clear Feedback**: Tool shows full path of generated OpenAPI file

#### Example Usage
```bash
# Basic usage - generates spring-petclinic-rest-openapi.yaml in current directory
java -jar apiscan-cli.jar "C:\path\to\spring-petclinic-rest"

# Custom format - generates JSON instead of YAML
java -jar apiscan-cli.jar -f json "C:\path\to\spring-petclinic-rest"

# Custom location - saves to specific path
java -jar apiscan-cli.jar -o my-api-spec.yaml "C:\path\to\spring-petclinic-rest"
```

#### Sample Output
```
[SUCCESS] OpenAPI specification saved: C:\current\directory\spring-petclinic-rest-openapi.yaml
```

This ensures APISCAN delivers on its **core promise** of generating OpenAPI documentation files, making it immediately useful for enterprise API documentation workflows.

## DTO Schema Resolution and Generation

### Advanced DTO Support for Enterprise APIs

APISCAN now includes sophisticated DTO (Data Transfer Object) schema resolution and generation, addressing a critical enterprise requirement: **handling generated code and complex data structures** in OpenAPI specifications.

#### Core DTO Functionality

**Intelligent DTO Discovery**: APISCAN automatically searches for DTO classes in common locations:
- `target/generated-sources/openapi/src/main/java` (Generated OpenAPI DTOs)
- `build/generated-sources/openapi/src/main/java` (Gradle generated DTOs)
- `src/main/java` (Manual/custom DTOs)
- Additional annotation processor locations

**AST-Based Schema Parsing**: Using JavaParser, APISCAN analyzes DTO source code to extract:
- Field names and types (String, Integer, List<>, etc.)
- Validation constraints (`@NotNull`, `@Size`, etc.)
- Documentation from JavaDoc and annotations (`@Schema`)
- Collection types and nested object structures

**OpenAPI 3.0.3 Compliant Output**: Generated schemas follow OpenAPI best practices:
- Proper `$ref` references to components/schemas
- Detailed field type mapping (Java → OpenAPI types)
- Required field detection from validation annotations
- Array and nested object support

#### Enterprise DTO Patterns Supported

1. **Generated OpenAPI DTOs**: Complete support for Spring Boot OpenAPI code generation
   ```java
   @Schema(name = "Owner", description = "A pet owner.")
   public class OwnerDto {
       @NotNull @Size(min = 1, max = 30)
       private String firstName;
       // ... other fields
   }
   ```

2. **Dual DTO Pattern**: Handles read/write model separation common in enterprise APIs
   - `OwnerDto` - Full representation (includes ID, read-only fields)
   - `OwnerFieldsDto` - Write operations (editable fields only)

3. **Missing DTO Graceful Handling**: When DTO source is unavailable (e.g., not built yet):
   ```yaml
   components:
     schemas:
       MissingDto:
         type: object
         description: "DTO class 'MissingDto' - Schema not available (generated source may be missing)"
         properties:
           _schemaPlaceholder:
             type: string
             description: "This DTO schema is not available. The class 'MissingDto' may be generated code that needs to be built first."
   ```

4. **Complex Nested Structures**: Supports enterprise entity relationships:
   - Collections: `List<PetDto>` → array with DTO item references
   - Nested objects: `PetTypeDto` → proper schema reference
   - Generic type extraction and mapping

#### OpenAPI Schema Generation Examples

**Before DTO Support**:
```yaml
post:
  responses:
    "200":
      content:
        application/json:
          schema:
            type: object
            description: "Response of type: OwnerDto"
```

**After DTO Support**:
```yaml
post:
  responses:
    "200":
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/OwnerDto'

components:
  schemas:
    OwnerDto:
      type: object
      description: "A pet owner."
      properties:
        firstName:
          type: string
        lastName:
          type: string
        address:
          type: string
        city:
          type: string
        telephone:
          type: string
        id:
          type: integer
        pets:
          type: array
          items:
            type: object
            description: "Object of type: PetDto"
      required:
        - firstName
        - lastName
        - address
        - city
        - telephone
```

#### Enterprise Impact and Benefits

**For API Documentation Teams**:
- **Rich Schema Information**: Complete field descriptions, types, and constraints
- **Professional Output**: OpenAPI specifications that work seamlessly with tools like Swagger UI, Postman, and code generators
- **No Manual Schema Maintenance**: DTOs automatically discovered and parsed

**For Enterprise Development**:
- **Generated Code Support**: Works with popular OpenAPI generators (Spring Boot, Quarkus)
- **Build Process Integration**: Handles DTOs that exist only after compilation
- **Contract-First Development**: Supports interface-based API development patterns

**For Microservices Architecture**:
- **Schema Consistency**: Ensures DTO schemas match actual code structure
- **Cross-Service Documentation**: Provides complete data model documentation for API consumers
- **Development Workflow Integration**: Works whether DTOs are generated or manually created

#### Technical Implementation

**DtoSchemaResolver Class**: Core component for DTO discovery and schema generation
- **Caching System**: Avoids re-parsing the same DTO multiple times
- **Search Path Prioritization**: Prefers generated sources over manual sources
- **Error Recovery**: Graceful fallback to placeholder schemas

**SwaggerCoreOpenApiGenerator Integration**: Enhanced OpenAPI generator
- **Schema References**: Proper `$ref` usage instead of inline schemas
- **Components Section**: Centralized schema definitions
- **Type System**: Complete Java to OpenAPI type mapping

#### Real-World Results

**spring-petclinic-rest Project**:
- **Before**: Generic object descriptions without field details
- **After**: Complete DTO schemas with 7+ detailed data models
- **Generated Schemas**: OwnerDto, PetDto, VetDto, VisitDto, SpecialtyDto, PetTypeDto, UserDto
- **Professional Output**: Enterprise-grade OpenAPI specification suitable for production documentation

This DTO support transforms APISCAN from a basic endpoint scanner into a comprehensive API documentation tool that handles the complexity of modern enterprise Java applications with generated code, validation frameworks, and sophisticated data models.

## OpenAPI Validation & Standards Compliance

### Critical Learning: Exact Parameter Name Matching Required

APISCAN now uses **Swagger Core library** instead of custom OpenAPI generation to ensure full OpenAPI 3.0.3 specification compliance. A critical lesson learned during development:

#### OpenAPI Validation Rules
**Path parameters must have exact name matching between URL segments and parameter definitions.**

#### Example Issue Fixed:
- **Path**: `/api/vet/{id}`
- **Wrong**: Parameter name `vetId` ❌ 
- **Correct**: Parameter name `id` ✅

#### Root Cause Analysis:
Initial implementation attempted "smart" parameter matching (e.g., matching `vetId` parameter to `{id}` path segment). However, OpenAPI specification requires exact matching for validation tools and code generators to work correctly.

#### Solution Implemented:
1. **Extract Path Parameter Names**: Parse URL paths to identify all `{paramName}` segments
2. **Exact Matching**: Only treat parameters as path parameters if names match exactly
3. **Auto-Generate Missing Parameters**: Create path parameters for unmatched path segments
4. **Swagger Core Library**: Use industry-standard library instead of custom implementation

#### Validation Errors Resolved:
```yaml
# Before (Invalid):
paths:
  /api/vet/{id}:
    put:
      parameters:
      - name: vetId        # ❌ Does not match {id} in path
        in: path
        
# After (Valid):
paths:  
  /api/vet/{id}:
    put:
      parameters:
      - name: id           # ✅ Exact match with {id} in path
        in: path
```

#### Enterprise Impact:
- **OpenAPI Viewers**: Specifications now display correctly in Swagger UI, ReDoc, Postman
- **Code Generation**: Tools can generate accurate client libraries and server stubs  
- **API Documentation**: No validation errors in enterprise documentation workflows
- **CI/CD Integration**: Specifications pass automated validation in build pipelines

#### Test Coverage:
Comprehensive test suite added covering:
- Exact parameter name matching scenarios
- Missing path parameter detection and auto-generation
- OpenAPI 3.0.3 compliance validation 
- Real-world Spring project patterns (spring-petclinic-rest: 35 endpoints tested)

This fix ensures APISCAN generates production-ready OpenAPI specifications that meet enterprise quality standards.

## Request Body Detection for Inferred Endpoints

### Enhanced DTO Parameter Recognition

APISCAN now properly detects and includes request body parameters when inferring endpoints from @Override methods, addressing a critical gap in OpenAPI generation for interface-based controllers.

#### The Problem
When controllers implement interfaces (common in generated code or contract-first development), the @Override methods often lack @RequestBody annotations. This resulted in missing request body definitions in the generated OpenAPI specification, even though the methods clearly accept DTO parameters.

#### The Solution  
Enhanced the SpringFrameworkScanner to intelligently identify DTO parameters as request bodies for POST/PUT/PATCH methods:

1. **Smart DTO Detection**: Recognizes common DTO patterns without requiring @RequestBody annotation:
   - Types ending with: Dto, DTO, Request, Response, Model, Form, Input, Output, Payload
   - Complex types that are not simple Java types (String, Integer, etc.)
   - Excludes parameters with @PathVariable, @RequestParam, or @RequestHeader annotations

2. **HTTP Method Awareness**: Only treats DTO parameters as request bodies for modifying operations:
   - POST methods: Create operations expecting request bodies
   - PUT methods: Update operations with full replacement
   - PATCH methods: Partial update operations
   - GET/DELETE methods: No automatic request body inference

3. **Backward Compatibility**: Continues to respect explicit @RequestBody annotations when present

#### Real-World Impact

**spring-petclinic-rest Project Results**:
- **Before Fix**: POST /api/owners had no request body defined
- **After Fix**: POST /api/owners correctly includes OwnerFieldsDto request body
- **All Endpoints Fixed**: 15+ POST/PUT endpoints now have proper request body schemas

**Example OpenAPI Output**:
```yaml
/api/owners:
  post:
    operationId: OwnerRestController_addOwner
    requestBody:
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/OwnerFieldsDto'
      required: true
    responses:
      "200":
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OwnerDto'
```

#### Technical Implementation

The fix involves two key changes in SpringFrameworkScanner:

1. **Enhanced extractRequestBody Method**: 
   - Checks HTTP method to determine if request body is expected
   - Identifies DTO parameters based on naming patterns and type complexity
   - Automatically creates request body definitions for qualifying parameters

2. **Improved extractParameter Method**:
   - Skips DTO parameters that will be handled as request bodies
   - Prevents duplicate parameter definitions in OpenAPI

#### Test Coverage
Added comprehensive test `testRequestBodyDetectionInInferredEndpoints` that verifies:
- POST endpoints have request bodies for DTO parameters
- PUT endpoints have request bodies for DTO parameters  
- GET endpoints do not have request bodies added
- Request body schemas correctly reference DTO types

This enhancement ensures that APISCAN generates complete and accurate OpenAPI specifications for all Spring REST APIs, regardless of whether they use direct annotations or interface-based implementations.