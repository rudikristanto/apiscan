# APISCAN - API Endpoint Scanner

## Project Overview
**apiscan** is a CLI application that extracts API endpoints from various implementation types and generates OpenAPI documentation.

## Core Requirements

### Goal
- Create OpenAPI file in JSON or YAML format (✅ **ALWAYS GENERATED BY DEFAULT**)
- Output summary report - informative to users

### Critical Design Constraints
- **NO COMPILATION/BUILD REQUIRED**: The input project to be analyzed should NOT be built or compiled. Many enterprise projects cannot be compiled due to dependencies, configurations, or access restrictions. The tool MUST analyze source code as-is by reading files directly.
- CLI application
- Enterprise grade quality

### Design Considerations
- Extensible to analyze other frameworks (Quarkus, Struts) and languages (.NET Core)
- Testable architecture
- Easy to maintain
- Best performance
- AST-based implementation for accurate extraction

### MVP Scope
- Java-based API implementations
- Spring MVC support
- Spring Boot support

### Test Projects
- `C:\Users\Rudi Kristanto\prj\spring-petclinic-rest`
- `C:\Users\Rudi Kristanto\prj\shopizer`

## Development Guidelines
1. Always analyze source code without compilation
2. Use AST parsing for accurate endpoint extraction
3. Focus on extensibility for future framework support
4. Maintain clear separation between framework-specific analyzers

## Key Features

### Interface-Based Endpoint Detection
The Spring framework scanner supports multiple approaches for API endpoint detection:

1. **Direct Annotation Scanning**: Extracts endpoints from controller classes with Spring mapping annotations (`@GetMapping`, `@PostMapping`, etc.)

2. **Interface Implementation Analysis**: When controllers implement API interfaces (common in generated code or contract-first development), the scanner:
   - Collects all interfaces with Spring mapping annotations in a first pass
   - Matches controller classes that implement these interfaces
   - Extracts endpoint definitions from the interface methods

3. **Method Inference**: For cases where interface definitions are not available (external dependencies, generated code), the scanner can infer API endpoints from controller methods marked with `@Override`:
   - Analyzes method names to determine HTTP methods (`listOwners` → GET, `addOwner` → POST, `updateOwner` → PUT, `deleteOwner` → DELETE)
   - Constructs RESTful paths based on method names and parameters (`getOwner(Integer ownerId)` → `/owners/{ownerId}`)
   - Supports nested resource patterns (`addPetToOwner` → `/owners/{ownerId}/pets`)

### Test Results
- **spring-petclinic-rest**: Successfully detected 35 endpoints across 8 controllers
- **Before improvement**: 1 endpoint detected
- **After improvement**: 35 endpoints detected (35x improvement)

### Supported Patterns
- Standard REST controllers with direct annotations
- Interface-based API definitions (OpenAPI generated, contract-first)
- Mixed patterns within the same project
- Nested resource relationships (owners/pets/visits)
- All standard HTTP methods (GET, POST, PUT, DELETE, PATCH)

## Test Coverage

### Comprehensive Test Suite
The APISCAN tool includes extensive test coverage for all major enterprise Spring Java application scenarios:

#### Core Component Tests
- **JavaSourceParserTest**: AST parsing functionality, file handling, error scenarios
- **ApiEndpointTest**: Data model validation, parameter handling, request/response structures

#### Enterprise API Pattern Tests
1. **Direct Annotation-Based APIs**
   - Controllers with Spring mapping annotations (`@GetMapping`, `@PostMapping`, etc.)
   - Standard RESTful CRUD operations
   - Path parameter and request body handling
   - Example: `@RestController` with `@RequestMapping("/api/users")`

2. **Interface-Based APIs with Available Definitions**
   - Controllers implementing interfaces that contain Spring annotations
   - Contract-first development patterns
   - OpenAPI code generation scenarios
   - Example: `ProductController implements ProductsApi` where `ProductsApi` has annotations

3. **Interface-Based APIs with Missing Definitions (@Override Inference)**
   - Controllers implementing external interfaces (JAR dependencies, generated code)
   - Intelligent endpoint inference from method names and parameters
   - Method pattern recognition (`listOrders` → GET, `addOrder` → POST, `deleteOrder` → DELETE)
   - Path construction from method signatures (`getOrder(Integer orderId)` → `/orders/{orderId}`)
   - Example: Real-world scenario like spring-petclinic-rest project

4. **Mixed Implementation Scenarios**
   - Projects combining both direct annotation and interface-based controllers
   - Multiple architectural patterns within the same codebase
   - Different teams using different approaches

5. **Complex Nested Resource Hierarchies**
   - Multi-level REST resource relationships
   - Enterprise-grade resource structures
   - Examples: 
     - `companies/{id}/departments/{id}/employees/{id}/projects`
     - `owners/{id}/pets/{id}/visits`
   - Intelligent nested path inference from method names

6. **HTTP Method and Annotation Variations**
   - `@RequestMapping` with method parameters
   - Specialized annotations (`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, `@PatchMapping`)
   - Parameter annotations (`@PathVariable`, `@RequestParam`, `@RequestBody`, `@RequestHeader`)
   - Security annotations (`@PreAuthorize`) - handled gracefully

7. **CLI Integration Testing**
   - End-to-end command-line interface testing
   - Output format validation (JSON/YAML)
   - Error handling and edge cases
   - Real project scanning verification

#### Test Scenarios Covering Enterprise Requirements

**Scenario 1: Legacy Enterprise Application**
- Mixed direct annotations and interface implementations
- Complex business domain models
- Multi-module Maven projects
- Security-enabled endpoints

**Scenario 2: Microservices Architecture**
- Contract-first API development
- Generated client/server stubs
- Interface definitions in separate modules
- Cross-service communication patterns

**Scenario 3: Code Generation Workflows**
- OpenAPI specification → Java code generation
- Missing interface source code (JAR dependencies)
- Method signature-based endpoint inference
- Automated documentation generation

**Scenario 4: Migration Projects**
- Gradual migration from older frameworks
- Mixed annotation styles within controllers
- Backward compatibility requirements
- Documentation catch-up scenarios

**Scenario 5: Enterprise Integration**
- Complex nested resource hierarchies
- Business entity relationships
- Multi-level authorization patterns
- Comprehensive API documentation needs

### Test Execution and Quality Assurance
- **Maven Integration**: Tests run as part of build process (`mvn test`)
- **Java 17 Compatibility**: Modern language features with text blocks
- **Flexible Assertions**: Robust test expectations that accommodate inference variations
- **Performance Testing**: Large project scanning (spring-petclinic-rest: 35 endpoints)
- **Error Handling**: Malformed code, missing dependencies, parsing failures
- **Output Validation**: Generated OpenAPI specifications, CLI reports

### Continuous Quality Metrics
- **Code Coverage**: Core parsing, framework detection, endpoint extraction
- **Real-world Validation**: Tested against production Spring projects
- **Regression Testing**: Ensures existing functionality remains intact
- **Edge Case Handling**: Unusual method names, complex generics, annotation variations

## Enhanced User Experience

### Professional CLI Output Formatting
The APISCAN tool now features enterprise-grade console output with improved readability and professional presentation:

#### Key Improvements
1. **Professional Header Design**: Clean ASCII formatting and clear branding (Windows-compatible)
   ```
   =========================================================
   |                   APISCAN v1.0.0                     |
   |            Enterprise API Endpoint Scanner           |
   =========================================================
   ```

2. **Clean Progress Indicators**: Clear status messages without verbose debug output
   - Framework detection confirmation
   - Scan progress with timing information
   - Endpoint discovery count
   - OpenAPI generation status

3. **Structured Summary Reports**: Professionally formatted scan results
   - **Project Information**: Clean project name extraction and framework details
   - **Performance Metrics**: File scan counts and duration with proper number formatting
   - **HTTP Method Breakdown**: Tabulated endpoint counts by method with icons
   - **Controller Organization**: Sorted by endpoint count, easy to identify high-traffic controllers
   - **Detailed Endpoint Listing**: Organized by controller with hierarchical display

4. **Enhanced Data Visualization**:
   - **HTTP Method Indicators**: [GET], [POST], [PUT], [DEL], [PATCH]
   - **ASCII-Safe Formatting**: Cross-platform compatible console output
   - **Parameter Display**: Compact parameter information without clutter
   - **Deprecation Indicators**: Clear [DEPRECATED] marking of deprecated endpoints

5. **Reduced Debug Noise**: 
   - **Production Logging**: Debug information sent to log files, not console
   - **Clean Console Output**: Only essential information displayed to users
   - **Verbose Mode Available**: Full details accessible with `-v` flag when needed

#### Example Professional Output
```
[INFO] Framework detected: Spring
[INFO] Scanning for API endpoints...
[SUCCESS] Scan completed in 1,266ms
[RESULT] Found 35 API endpoints

=========================================================
|                    SCAN SUMMARY                      |
=========================================================
Project:          spring-petclinic-rest
Framework:        Spring  
Files scanned:    83
Duration:         1,266 ms
Total endpoints:  35

HTTP Methods:
-----------------------------------------
  [DEL] DELETE   6 endpoints
  [GET] GET      14 endpoints
  [POST] POST     8 endpoints
  [PUT] PUT      7 endpoints

Controllers:
-----------------------------------------
  [ 9] OwnerRestController
  [ 5] SpecialtyRestController
  [ 5] VetRestController
  [ 5] PetTypeRestController
  [ 5] VisitRestController
  [ 4] PetRestController
  [ 1] UserRestController
  [ 1] RootRestController

=========================================================
|             SCAN COMPLETED SUCCESSFULLY!             |
=========================================================
```

### Output Format Testing
Comprehensive test coverage for the enhanced output formatting:
- **ReportGeneratorTest**: Complete test suite validating all formatting improvements
- **ASCII-Safe Presentation**: Verification of cross-platform compatible formatting
- **Content Organization**: Testing of tabular layouts and hierarchical displays  
- **Edge Case Handling**: Long controller names, empty results, error scenarios
- **Console Output Capture**: Systematic validation of all output sections

### Cross-Platform Compatibility
The enhanced output formatting addresses common Windows console encoding issues:
- **ASCII-Safe Characters**: Replaced Unicode box-drawing and emoji with standard ASCII
- **Windows Console Support**: Fully compatible with Windows Command Prompt and PowerShell
- **Universal Display**: Consistent appearance across Windows, macOS, and Linux terminals
- **Character Encoding Independent**: No dependency on UTF-8 console support
- **Professional Appearance**: Maintains enterprise-grade visual quality with standard characters

### User Experience Benefits
1. **Professional Appearance**: Enterprise-grade console output suitable for business presentations
2. **Information Density**: Maximum useful information in minimal screen space
3. **Quick Scanning**: Easy to identify key metrics and problem areas at a glance
4. **Consistent Formatting**: Standardized presentation across all scan results
5. **Reduced Cognitive Load**: Clean, organized information hierarchy
6. **Tool Credibility**: Professional appearance enhances user trust and adoption

## OpenAPI File Generation

### Core Functionality Alignment
APISCAN now properly fulfills its primary goal from the Core Requirements - **creating OpenAPI files by default**:

#### Default Behavior (Fixed)
- **Automatic Generation**: OpenAPI files are **always generated** when scanning a project
- **Smart File Naming**: Auto-generates filename as `{project-name}-openapi.{format}` in current directory
- **Format Support**: YAML (default) and JSON formats available with `-f/--format` flag
- **User-Friendly**: No need to remember `-o/--output` parameter for basic usage

#### File Location
- **Default Location**: Generated in the current working directory (where you run APISCAN)
- **Custom Location**: Use `-o/--output` to specify alternative file path
- **Clear Feedback**: Tool shows full path of generated OpenAPI file

#### Example Usage
```bash
# Basic usage - generates spring-petclinic-rest-openapi.yaml in current directory
java -jar apiscan-cli.jar "C:\path\to\spring-petclinic-rest"

# Custom format - generates JSON instead of YAML
java -jar apiscan-cli.jar -f json "C:\path\to\spring-petclinic-rest"

# Custom location - saves to specific path
java -jar apiscan-cli.jar -o my-api-spec.yaml "C:\path\to\spring-petclinic-rest"
```

#### Sample Output
```
[SUCCESS] OpenAPI specification saved: C:\current\directory\spring-petclinic-rest-openapi.yaml
```

This ensures APISCAN delivers on its **core promise** of generating OpenAPI documentation files, making it immediately useful for enterprise API documentation workflows.

## DTO Schema Resolution and Generation

### Advanced DTO Support for Enterprise APIs

APISCAN now includes sophisticated DTO (Data Transfer Object) schema resolution and generation, addressing a critical enterprise requirement: **handling generated code and complex data structures** in OpenAPI specifications.

#### Core DTO Functionality

**Intelligent DTO Discovery**: APISCAN automatically searches for DTO classes in common locations:
- `target/generated-sources/openapi/src/main/java` (Generated OpenAPI DTOs)
- `build/generated-sources/openapi/src/main/java` (Gradle generated DTOs)
- `src/main/java` (Manual/custom DTOs)
- Additional annotation processor locations

**AST-Based Schema Parsing**: Using JavaParser, APISCAN analyzes DTO source code to extract:
- Field names and types (String, Integer, List<>, etc.)
- Validation constraints (`@NotNull`, `@Size`, etc.)
- Documentation from JavaDoc and annotations (`@Schema`)
- Collection types and nested object structures

**OpenAPI 3.0.3 Compliant Output**: Generated schemas follow OpenAPI best practices:
- Proper `$ref` references to components/schemas
- Detailed field type mapping (Java → OpenAPI types)
- Required field detection from validation annotations
- Array and nested object support

#### Enterprise DTO Patterns Supported

1. **Generated OpenAPI DTOs**: Complete support for Spring Boot OpenAPI code generation
   ```java
   @Schema(name = "Owner", description = "A pet owner.")
   public class OwnerDto {
       @NotNull @Size(min = 1, max = 30)
       private String firstName;
       // ... other fields
   }
   ```

2. **Dual DTO Pattern**: Handles read/write model separation common in enterprise APIs
   - `OwnerDto` - Full representation (includes ID, read-only fields)
   - `OwnerFieldsDto` - Write operations (editable fields only)

3. **Missing DTO Graceful Handling**: When DTO source is unavailable (e.g., not built yet):
   ```yaml
   components:
     schemas:
       MissingDto:
         type: object
         description: "DTO class 'MissingDto' - Schema not available (generated source may be missing)"
         properties:
           _schemaPlaceholder:
             type: string
             description: "This DTO schema is not available. The class 'MissingDto' may be generated code that needs to be built first."
   ```

4. **Complex Nested Structures**: Supports enterprise entity relationships:
   - Collections: `List<PetDto>` → array with DTO item references
   - Nested objects: `PetTypeDto` → proper schema reference
   - Generic type extraction and mapping

#### OpenAPI Schema Generation Examples

**Before DTO Support**:
```yaml
post:
  responses:
    "200":
      content:
        application/json:
          schema:
            type: object
            description: "Response of type: OwnerDto"
```

**After DTO Support**:
```yaml
post:
  responses:
    "200":
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/OwnerDto'

components:
  schemas:
    OwnerDto:
      type: object
      description: "A pet owner."
      properties:
        firstName:
          type: string
        lastName:
          type: string
        address:
          type: string
        city:
          type: string
        telephone:
          type: string
        id:
          type: integer
        pets:
          type: array
          items:
            type: object
            description: "Object of type: PetDto"
      required:
        - firstName
        - lastName
        - address
        - city
        - telephone
```

#### Enterprise Impact and Benefits

**For API Documentation Teams**:
- **Rich Schema Information**: Complete field descriptions, types, and constraints
- **Professional Output**: OpenAPI specifications that work seamlessly with tools like Swagger UI, Postman, and code generators
- **No Manual Schema Maintenance**: DTOs automatically discovered and parsed

**For Enterprise Development**:
- **Generated Code Support**: Works with popular OpenAPI generators (Spring Boot, Quarkus)
- **Build Process Integration**: Handles DTOs that exist only after compilation
- **Contract-First Development**: Supports interface-based API development patterns

**For Microservices Architecture**:
- **Schema Consistency**: Ensures DTO schemas match actual code structure
- **Cross-Service Documentation**: Provides complete data model documentation for API consumers
- **Development Workflow Integration**: Works whether DTOs are generated or manually created

#### Technical Implementation

**DtoSchemaResolver Class**: Core component for DTO discovery and schema generation
- **Caching System**: Avoids re-parsing the same DTO multiple times
- **Search Path Prioritization**: Prefers generated sources over manual sources
- **Error Recovery**: Graceful fallback to placeholder schemas

**SwaggerCoreOpenApiGenerator Integration**: Enhanced OpenAPI generator
- **Schema References**: Proper `$ref` usage instead of inline schemas
- **Components Section**: Centralized schema definitions
- **Type System**: Complete Java to OpenAPI type mapping

#### Real-World Results

**spring-petclinic-rest Project**:
- **Before**: Generic object descriptions without field details
- **After**: Complete DTO schemas with 7+ detailed data models
- **Generated Schemas**: OwnerDto, PetDto, VetDto, VisitDto, SpecialtyDto, PetTypeDto, UserDto
- **Professional Output**: Enterprise-grade OpenAPI specification suitable for production documentation

This DTO support transforms APISCAN from a basic endpoint scanner into a comprehensive API documentation tool that handles the complexity of modern enterprise Java applications with generated code, validation frameworks, and sophisticated data models.

### Recursive DTO Reference Resolution

APISCAN includes sophisticated recursive reference resolution to ensure that all DTO schemas referenced in the OpenAPI specification are properly included in the `components.schemas` section.

#### Problem Solved
The initial implementation could generate broken OpenAPI specifications where nested DTO references (e.g., `UserDto.roles` referencing `RoleDto`) would create `$ref` links to schemas that weren't included in the components section, causing validation errors:

```
Semantic error at components.schemas.UserDto.properties.roles.items.$ref
$refs must reference a valid location in the document
```

#### Solution Implementation
**Recursive Schema Resolution**: Enhanced the `SwaggerCoreOpenApiGenerator` with a `resolveNestedDtoReferences` method that:

1. **Analyzes All DTO Properties**: Scans through each resolved DTO schema to identify nested `$ref` references
2. **Resolves Referenced DTOs**: Automatically resolves and includes any DTOs referenced by `$ref` paths
3. **Handles Array Items**: Processes array item schemas that reference DTOs (e.g., `List<RoleDto>`)
4. **Prevents Infinite Loops**: Uses the existing `dtoSchemas` cache to avoid circular reference issues
5. **Recursive Processing**: Applies the same analysis to newly resolved DTOs to catch multi-level references

#### Technical Implementation Details

**Enhanced `buildSchemaForType` Method**:
```java
// Resolve DTO schema
Schema<?> resolvedSchema = schemaResolver.resolveSchema(className);
if (resolvedSchema != null) {
    dtoSchemas.put(className, resolvedSchema);
    
    // Recursively resolve any nested DTO references in the resolved schema
    resolveNestedDtoReferences(resolvedSchema, schemaResolver, dtoSchemas);
    
    // Return reference to the schema in components
    Schema<Object> refSchema = new Schema<>();
    refSchema.$ref("#/components/schemas/" + className);
    return refSchema;
}
```

**New `resolveNestedDtoReferences` Method**: Comprehensive recursive resolution that handles:
- Direct DTO property references (`$ref: '#/components/schemas/RoleDto'`)
- Array item references (`List<RoleDto>` → items with `$ref`)
- Nested object properties with further DTO references
- Multi-level reference chains (DTO → DTO → DTO)

#### Real-World Impact

**Before Fix**:
- Generated OpenAPI files with broken `$ref` links
- Semantic validation errors when opening specifications
- Incomplete schema information for API consumers
- Manual intervention required to fix reference issues

**After Fix**:
- All referenced DTOs automatically included in `components.schemas`
- Valid OpenAPI 3.0.3 specifications that pass validation
- Complete schema information for nested object structures
- Seamless integration with tools like Swagger UI, Postman, and code generators

#### Example Result

**spring-petclinic-rest Project**: The `UserDto.roles` field now properly references `RoleDto`, and the generated specification includes:

```yaml
components:
  schemas:
    UserDto:
      type: object
      properties:
        roles:
          type: array
          items:
            $ref: '#/components/schemas/RoleDto'
    RoleDto:
      type: object
      properties:
        name:
          type: string
```

#### Test Coverage
Added comprehensive test `shouldHandleBrokenSchemaReferences()` in `DtoSchemaResolverTest` to validate:
- Graceful handling of missing DTO references
- Proper fallback to placeholder schemas when resolution fails
- Prevention of broken `$ref` generation in edge cases

This enhancement ensures that APISCAN generates production-ready OpenAPI specifications with complete schema definitions, meeting enterprise quality standards for API documentation workflows.

## Comprehensive HTTP Response Code Generation

### Enterprise-Grade Response Standards
APISCAN now generates comprehensive HTTP response codes that match enterprise API documentation standards, significantly enhancing the quality and completeness of generated OpenAPI specifications.

#### Key Response Code Features

**Complete HTTP Status Code Coverage**:
- **200 OK**: Success responses with appropriate content types and schemas
- **201 Created**: For POST operations (resource creation)
- **304 Not Modified**: For GET and PUT operations (caching support)
- **400 Bad Request**: For malformed requests with error schema
- **404 Not Found**: For resource-specific operations with path parameters
- **500 Internal Server Error**: For server errors with error schema

**Smart Response Generation Logic**:
- **Method-Specific Responses**: Different response codes based on HTTP method (GET vs POST vs PUT vs DELETE)
- **Resource-Aware Error Messages**: "owner not found", "pet not found" instead of generic errors
- **Conditional 304 Support**: Only added for cacheable operations (GET, PUT, PATCH)
- **Path Parameter Detection**: 404 responses only added for endpoints with path parameters

#### Enterprise API Pattern Support

**Before Enhancement**:
```yaml
responses:
  "200":
    description: Successful response
    content:
      application/json:
        schema:
          $ref: '#/components/schemas/OwnerDto'
```

**After Enhancement**:
```yaml
responses:
  "200":
    description: owner details found and returned.
    content:
      application/json:
        schema:
          $ref: '#/components/schemas/OwnerDto'
  "304":
    description: Not modified.
    content:
      application/json:
        schema:
          $ref: '#/components/schemas/OwnerDto'
  "400":
    description: Bad request.
    content:
      application/json:
        schema:
          $ref: '#/components/schemas/ProblemDetail'
  "404":
    description: owner not found.
    content:
      application/json:
        schema:
          $ref: '#/components/schemas/ProblemDetail'
  "500":
    description: Server error.
    content:
      application/json:
        schema:
          $ref: '#/components/schemas/ProblemDetail'
```

#### Error Schema Integration

**ProblemDetail Support**: 
- Automatic `ProblemDetail` schema references for error responses
- Graceful fallback to generic error schema when ProblemDetail is not available
- Consistent error structure across all API endpoints

**Example Error Schema**:
```yaml
ProblemDetail:
  type: object
  properties:
    title:
      type: string
      description: Error title
    detail:
      type: string  
      description: Error detail
    status:
      type: integer
      description: HTTP status code
```

#### Response Content Optimization

**Content Type Consistency**: All responses include proper `application/json` content types
**Schema Reuse**: 304 responses reuse existing success response content for efficiency
**Content Inheritance**: Error responses follow consistent schema patterns

#### Real-World Impact

**spring-petclinic-rest Results**:
- **Before**: Basic 200 response only
- **After**: Complete enterprise response coverage (200, 304, 400, 404, 500)
- **35 Endpoints Enhanced**: All endpoints now include comprehensive response documentation
- **Error Handling**: Professional error response patterns throughout

**Enterprise Benefits**:
- **API Client Generation**: Better client library generation with proper error handling
- **Documentation Quality**: Professional-grade API documentation matching industry standards
- **Developer Experience**: Clear expectations for all possible API responses
- **Testing Support**: Complete response coverage for automated testing scenarios
- **Production Readiness**: Enterprise-grade error handling documentation

This enhancement brings APISCAN's OpenAPI generation to enterprise standards, providing comprehensive response documentation that matches the quality of manually crafted API specifications while maintaining the automation and consistency benefits of code-first documentation generation.

## Enhanced Nested Object Schema Resolution

### Enterprise-Grade DTO Reference Generation
APISCAN now generates proper schema references for nested DTO objects, eliminating empty object schemas and providing accurate example values in OpenAPI specifications.

#### Problem Solved
Previously, nested DTO fields were generating generic object descriptions instead of proper schema references:

**Before Enhancement**:
```yaml
PetFieldsDto:
  type: object
  properties:
    name:
      type: string
    type:
      type: object
      description: "Object of type: PetTypeDto"  # Empty object!
    birthDate:
      type: string
      format: date-time
```

This resulted in example values like:
```json
{
  "name": "string",
  "type": {},  // Empty object - not helpful!
  "birthDate": "2025-08-18T02:42:59.493Z"
}
```

#### Solution Implementation

**Enhanced DTO Schema Resolver**: Implemented intelligent nested object detection and reference generation:

1. **DTO Class Detection**: Identifies classes that should be referenced based on naming patterns
   - Classes ending with `Dto`, `DTO`, `Response`, `Request`, `Entity`, `Model`
   - Classes already resolved in the schema cache

2. **Proper Reference Generation**: Creates `$ref` schema references instead of empty objects
3. **Collection Support**: Handles nested DTOs within collections (`List<PetDto>`, `Set<SpecialtyDto>`)
4. **Fallback Strategy**: Gracefully handles unavailable DTOs with descriptive object schemas

**After Enhancement**:
```yaml
PetFieldsDto:
  type: object
  properties:
    name:
      type: string
    type:
      $ref: '#/components/schemas/PetTypeDto'  # Proper reference!
    birthDate:
      type: string
      format: date-time
```

This generates accurate example values:
```json
{
  "name": "string",
  "type": {
    "name": "string",
    "id": 0
  },
  "birthDate": "2025-08-18T02:42:59.493Z"
}
```

#### Technical Implementation

**buildFieldSchema Method**: Core logic for handling nested object resolution:
```java
private Schema<Object> buildFieldSchema(String fieldType) {
    if (isPrimitiveType(fieldType)) {
        setSchemaType(fieldSchema, fieldType);
    } else if (isCollectionType(fieldType)) {
        // Handle arrays with proper item references
        fieldSchema.type("array");
        String itemType = extractGenericType(fieldType);
        Schema<Object> itemSchema = buildFieldSchema(itemType);
        fieldSchema.items(itemSchema);
    } else {
        // Create proper DTO references
        String simpleClassName = extractSimpleClassName(fieldType);
        if (isDtoClass(simpleClassName)) {
            fieldSchema.$ref("#/components/schemas/" + simpleClassName);
        } else {
            // Fallback for non-DTO objects
            fieldSchema.type("object");
            fieldSchema.description("Object of type: " + fieldType);
        }
    }
}
```

**Smart DTO Detection**: Recognizes enterprise DTO patterns:
```java
private boolean isDtoClass(String className) {
    return className.endsWith("Dto") || 
           className.endsWith("DTO") || 
           className.endsWith("Response") || 
           className.endsWith("Request") || 
           className.endsWith("Entity") ||
           className.endsWith("Model") ||
           schemaCache.containsKey(className);
}
```

#### Real-World Impact

**spring-petclinic-rest Results**:
- **Before**: Empty object schemas (`"type": {}`) in DTO examples
- **After**: Proper schema references with complete nested object definitions
- **Enhanced DTOs**: PetFieldsDto, OwnerDto, VetDto, UserDto, and more

**Example Improvements**:
- `PetFieldsDto.type` → `$ref: '#/components/schemas/PetTypeDto'`
- `OwnerDto.pets` → `$ref: '#/components/schemas/PetDto'` (array items)
- `UserDto.roles` → `$ref: '#/components/schemas/RoleDto'` (array items)
- `VetDto.specialties` → `$ref: '#/components/schemas/SpecialtyDto'` (array items)

#### Enterprise Benefits

**API Documentation Quality**:
- **Accurate Examples**: Proper nested object examples in OpenAPI viewers
- **Schema Validation**: Full validation support for nested structures
- **Type Safety**: Complete type information for code generation tools

**Developer Experience**:
- **IntelliSense Support**: Better IDE autocomplete for nested objects
- **API Client Generation**: Accurate client libraries with proper nested types
- **Testing**: Realistic test data generation from schema examples

**Tooling Integration**:
- **Swagger UI**: Displays complete nested object schemas with expandable sections
- **Postman**: Generates accurate request examples with nested object structures
- **Code Generators**: Creates proper DTOs with nested object relationships

#### Test Coverage

**Comprehensive Nested Object Testing**:
- `shouldCreateProperReferencesForNestedDtos()`: Validates proper `$ref` generation
- Collection handling tests for `List<DTO>` scenarios
- Fallback behavior for unavailable DTOs
- Cache integration testing for resolved schemas

This enhancement transforms DTO schema generation from basic object descriptions to enterprise-grade schema references, providing the detailed object structure information essential for professional API documentation and tooling integration.

## OpenAPI Validation & Standards Compliance

### Critical Learning: Exact Parameter Name Matching Required

APISCAN now uses **Swagger Core library** instead of custom OpenAPI generation to ensure full OpenAPI 3.0.3 specification compliance. A critical lesson learned during development:

#### OpenAPI Validation Rules
**Path parameters must have exact name matching between URL segments and parameter definitions.**

#### Example Issue Fixed:
- **Path**: `/api/vet/{id}`
- **Wrong**: Parameter name `vetId` ❌ 
- **Correct**: Parameter name `id` ✅

#### Root Cause Analysis:
Initial implementation attempted "smart" parameter matching (e.g., matching `vetId` parameter to `{id}` path segment). However, OpenAPI specification requires exact matching for validation tools and code generators to work correctly.

#### Solution Implemented:
1. **Extract Path Parameter Names**: Parse URL paths to identify all `{paramName}` segments
2. **Exact Matching**: Only treat parameters as path parameters if names match exactly
3. **Auto-Generate Missing Parameters**: Create path parameters for unmatched path segments
4. **Swagger Core Library**: Use industry-standard library instead of custom implementation

#### Validation Errors Resolved:
```yaml
# Before (Invalid):
paths:
  /api/vet/{id}:
    put:
      parameters:
      - name: vetId        # ❌ Does not match {id} in path
        in: path
        
# After (Valid):
paths:  
  /api/vet/{id}:
    put:
      parameters:
      - name: id           # ✅ Exact match with {id} in path
        in: path
```

#### Enterprise Impact:
- **OpenAPI Viewers**: Specifications now display correctly in Swagger UI, ReDoc, Postman
- **Code Generation**: Tools can generate accurate client libraries and server stubs  
- **API Documentation**: No validation errors in enterprise documentation workflows
- **CI/CD Integration**: Specifications pass automated validation in build pipelines

#### Test Coverage:
Comprehensive test suite added covering:
- Exact parameter name matching scenarios
- Missing path parameter detection and auto-generation
- OpenAPI 3.0.3 compliance validation 
- Real-world Spring project patterns (spring-petclinic-rest: 35 endpoints tested)

This fix ensures APISCAN generates production-ready OpenAPI specifications that meet enterprise quality standards.

## Request Body Detection for Inferred Endpoints

### Enhanced DTO Parameter Recognition

APISCAN now properly detects and includes request body parameters when inferring endpoints from @Override methods, addressing a critical gap in OpenAPI generation for interface-based controllers.

#### The Problem
When controllers implement interfaces (common in generated code or contract-first development), the @Override methods often lack @RequestBody annotations. This resulted in missing request body definitions in the generated OpenAPI specification, even though the methods clearly accept DTO parameters.

#### The Solution  
Enhanced the SpringFrameworkScanner to intelligently identify DTO parameters as request bodies for POST/PUT/PATCH methods:

1. **Smart DTO Detection**: Recognizes common DTO patterns without requiring @RequestBody annotation:
   - Types ending with: Dto, DTO, Request, Response, Model, Form, Input, Output, Payload
   - Complex types that are not simple Java types (String, Integer, etc.)
   - Excludes parameters with @PathVariable, @RequestParam, or @RequestHeader annotations

2. **HTTP Method Awareness**: Only treats DTO parameters as request bodies for modifying operations:
   - POST methods: Create operations expecting request bodies
   - PUT methods: Update operations with full replacement
   - PATCH methods: Partial update operations
   - GET/DELETE methods: No automatic request body inference

3. **Backward Compatibility**: Continues to respect explicit @RequestBody annotations when present

#### Real-World Impact

**spring-petclinic-rest Project Results**:
- **Before Fix**: POST /api/owners had no request body defined
- **After Fix**: POST /api/owners correctly includes OwnerFieldsDto request body
- **All Endpoints Fixed**: 15+ POST/PUT endpoints now have proper request body schemas

**Example OpenAPI Output**:
```yaml
/api/owners:
  post:
    operationId: OwnerRestController_addOwner
    requestBody:
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/OwnerFieldsDto'
      required: true
    responses:
      "200":
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OwnerDto'
```

#### Technical Implementation

The fix involves two key changes in SpringFrameworkScanner:

1. **Enhanced extractRequestBody Method**: 
   - Checks HTTP method to determine if request body is expected
   - Identifies DTO parameters based on naming patterns and type complexity
   - Automatically creates request body definitions for qualifying parameters

2. **Improved extractParameter Method**:
   - Skips DTO parameters that will be handled as request bodies
   - Prevents duplicate parameter definitions in OpenAPI

#### Test Coverage
Added comprehensive test `testRequestBodyDetectionInInferredEndpoints` that verifies:
- POST endpoints have request bodies for DTO parameters
- PUT endpoints have request bodies for DTO parameters  
- GET endpoints do not have request bodies added
- Request body schemas correctly reference DTO types

This enhancement ensures that APISCAN generates complete and accurate OpenAPI specifications for all Spring REST APIs, regardless of whether they use direct annotations or interface-based implementations.

## Professional Report Formatting with Aligned Indentation

### Enhanced Console Output Readability

APISCAN's report formatting has been significantly improved to provide professional, well-aligned output that enhances readability and maintains consistent indentation throughout the entire report.

#### The Problem
The initial report formatting had inconsistent indentation where:
- Parameter lines were not properly aligned with endpoint details
- HTTP method columns had varying widths
- Controller names could overflow their display area
- Sub-items (parameters, request bodies) lacked visual hierarchy

#### The Solution
Comprehensive formatting improvements across the ReportGenerator:

1. **Consistent Column Widths**: 
   - HTTP methods: Fixed 6-character width (`%-6s`)
   - API paths: Fixed 40-character width with truncation (`%-40s`)
   - Method icons: Standardized format (`[GET]`, `[POST]`, etc.)

2. **Professional Indentation**:
   - Main endpoint lines: 2-space indent
   - Parameters line: 15-space indent for perfect alignment
   - Request Body line: 15-space indent matching parameters
   - Creates clear visual hierarchy between endpoints and their details

3. **Smart Truncation**:
   - Long paths truncated at 40 characters with "..."
   - Long parameter lists truncated at 45 characters
   - Controller names handled gracefully at 35 characters

4. **Enhanced Visual Separators**:
   - Section headers use 70-character separators
   - Consistent use of dashed lines for subsections
   - Proper spacing between different report sections

#### Example Professional Output

**Before (Misaligned)**:
```
  [POST] POST    /api/owners                         addOwner
     Parameters: ownerId
  [GET] GET     /api/owners/{ownerId}               getOwner
     Parameters: ownerId
```

**After (Professional Alignment)**:
```
  [POST] POST   /api/owners                             addOwner
               Request Body: OwnerFieldsDto
  [GET] GET    /api/owners/{ownerId}                   getOwner
               Parameters: ownerId
  [PUT] PUT    /api/owners/{ownerId}                   updateOwner
               Parameters: ownerId
               Request Body: OwnerFieldsDto
```

#### Technical Implementation

**ReportGenerator Enhancements**:
- Fixed-width formatting using `String.format()` for consistent columns
- Proper 15-space indentation for sub-items (parameters, request bodies)
- Intelligent truncation helper method for handling long strings
- Separation of concerns between data formatting and display logic

**Key Changes**:
```java
// Professional column alignment
String method = String.format("%-6s", endpoint.getHttpMethod());
String path = String.format("%-40s", truncate(endpoint.getPath(), 40));

// Consistent sub-item indentation (15 spaces)
System.out.printf("               Parameters: %s%n", params);
System.out.printf("               Request Body: %s%n", bodyType);
```

#### Test Coverage
Added `testProfessionalIndentationFormatting` test that verifies:
- Parameters line has exactly 15-space indentation
- Request Body line has exactly 15-space indentation
- HTTP method icons are consistently formatted
- Long names are properly truncated

#### User Benefits

1. **Professional Presentation**: Report output suitable for documentation and presentations
2. **Improved Readability**: Clear visual hierarchy makes information easy to scan
3. **Consistent Experience**: Same formatting quality regardless of data variations
4. **Enterprise Quality**: Output meets professional standards expected in corporate environments
5. **Better Information Density**: More information visible without scrolling

This formatting enhancement ensures APISCAN produces professional, enterprise-grade reports that are both informative and visually appealing.

## Perfect Vertical URL Alignment Fix

### Resolved Critical Alignment Issue

Fixed the vertical alignment problem where endpoint URLs were not perfectly aligned due to inconsistent HTTP method icon widths, creating a professional, properly aligned output.

#### The Problem
URLs were misaligned because:
- Different HTTP method names have varying lengths (`GET` vs `POST` vs `DELETE`)  
- Method icons had inconsistent widths (`[GET]` = 5 chars, `[POST]` = 6 chars, `[DEL]` = 5 chars)
- This caused URLs to appear jagged and unprofessional in the output

#### The Solution
1. **Fixed Method Icon Width**: Used consistent 8-character width (`%-8s`) for all method icons
2. **Removed Redundant Method Names**: Eliminated duplicate method information (icon already shows method)
3. **Adjusted Sub-item Indentation**: Updated Parameters and Request Body indentation to 11 spaces to align perfectly under URLs

#### Example Before vs After

**Before (Misaligned URLs)**:
```
  [GET] GET     /api/owners                         listOwners
  [POST] POST    /api/owners                         addOwner  
  [DEL] DELETE  /api/owners/{ownerId}               deleteOwner
```

**After (Perfect Alignment)**:
```
  [GET]    /api/owners                              listOwners
           Parameters: lastName
  [POST]   /api/owners                              addOwner
           Request Body: OwnerFieldsDto
  [DEL]    /api/owners/{ownerId}                    deleteOwner
           Parameters: ownerId
```

#### Technical Implementation

**Key Changes**:
```java
// Fixed 8-character width for method icon ensures perfect URL alignment
String methodDisplay = String.format("%-8s", methodIcon);
String path = String.format("%-40s", truncate(endpoint.getPath(), 40));

// Simplified output format removes redundant method name
System.out.printf("  %s %s %s%s%n",
    methodDisplay,    // 8 chars fixed width
    path,            // 40 chars fixed width  
    methodName,
    deprecatedFlag
);

// Updated sub-item indentation (2 + 8 + 1 = 11 spaces)
System.out.printf("           Parameters: %s%n", params);
System.out.printf("           Request Body: %s%n", bodyType);
```

#### User Experience Benefits

1. **Perfect Visual Alignment**: All URLs start at exactly the same column position
2. **Cleaner Appearance**: Removed redundant method names for cleaner output
3. **Professional Presentation**: Enterprise-quality formatting suitable for documentation
4. **Consistent Visual Structure**: Predictable column layout regardless of method types
5. **Enhanced Readability**: Easy to scan endpoint lists with perfect alignment

#### Test Coverage
Updated `testProfessionalIndentationFormatting` to verify:
- Parameters and Request Body lines use 11-space indentation
- Perfect alignment under URLs regardless of HTTP method type
- Consistent formatting across all endpoint types

This alignment fix ensures APISCAN produces perfectly formatted, professional reports with consistent visual structure.

## Enhanced OpenAPI Generation with Enterprise-Grade Features

### Comprehensive OpenAPI 3.0.3 Specification Enhancement

APISCAN's OpenAPI generation has been significantly enhanced to produce enterprise-grade specifications that closely match industry standards and provide comprehensive API documentation.

#### Key Enhancements Implemented

1. **Auto-Generated Summaries and Descriptions**:
   - **Smart Summary Generation**: Automatically creates human-readable summaries based on HTTP method and resource
     - GET `/api/owners` → "List owners"
     - GET `/api/owners/{id}` → "Get a owner by ID" 
     - POST `/api/owners` → "Create a owner"
     - PUT `/api/owners/{id}` → "Update a owner by ID"
     - DELETE `/api/owners/{id}` → "Delete a owner by ID"
   
   - **Intelligent Descriptions**: Generates appropriate operation descriptions
     - List operations: "Returns an array of [resources]."
     - Single resource: "Returns the [resource] or a 404 error."
     - Create operations: "Creates a [resource]."
     - Update operations: "Updates the [resource] or returns a 404 error."

2. **Enhanced Parameter Documentation**:
   - **Auto-Generated Parameter Descriptions**: Path parameters automatically get descriptions like "The ID of the owner."
   - **Type Constraints**: Integer parameters include `format: int32` and `minimum: 0` for ID fields
   - **Proper Schema Validation**: Comprehensive type mapping from Java to OpenAPI types

3. **Multiple HTTP Response Codes**:
   - **Success Responses**: 
     - 200 for GET/PUT/DELETE operations
     - 201 for POST operations (resource creation)
   - **Error Responses**:
     - 400: "Bad request."
     - 404: "[Resource] not found." (for endpoints with path parameters)
     - 500: "Server error."

4. **Professional Response Content**:
   - **Proper Content Types**: `application/json` with correct schema references
   - **Array Responses**: Properly structured for list endpoints
   - **DTO Schema References**: Clean `$ref` references to components/schemas

#### Real-World Impact

**Before Enhancement**:
```yaml
get:
  operationId: OwnerRestController_getOwner
  parameters:
  - name: ownerId
    in: path
    required: true
    schema:
      type: integer
  responses:
    "200":
      description: Successful response
```

**After Enhancement**:
```yaml
get:
  tags:
  - Owner
  summary: Get a owner by ID
  description: Returns the owner or a 404 error.
  operationId: OwnerRestController_getOwner
  parameters:
  - name: ownerId
    in: path
    description: The ID of the owner.
    required: true
    schema:
      minimum: 0
      type: integer
      format: int32
  responses:
    "200":
      description: Successful response
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/OwnerDto'
    "400":
      description: Bad request.
    "404":
      description: owner not found.
    "500":
      description: Server error.
```

#### Technical Implementation

**SwaggerCoreOpenApiGenerator Enhancements**:
- `generateSummary()`: Intelligent summary generation based on HTTP method and resource type
- `generateDescription()`: Context-aware descriptions for different operation types
- `extractResourceFromPath()`: Smart resource name extraction from URL paths with pluralization handling
- `addDefaultResponses()`: Comprehensive response code generation based on operation type
- Enhanced parameter building with descriptions and constraints

**Resource Name Intelligence**:
- Plural to singular conversion: "owners" → "owner", "specialties" → "specialty"
- Path parsing to extract meaningful resource names
- Special handling for nested resources and API prefixes

#### Enterprise Benefits

1. **Professional Documentation**: Generated specifications are suitable for external API documentation
2. **Tool Compatibility**: Works seamlessly with Swagger UI, Postman, ReDoc, and other OpenAPI tools
3. **Code Generation Ready**: Specifications can be used to generate client libraries and server stubs
4. **Industry Standard Compliance**: Follows OpenAPI 3.0.3 best practices and conventions
5. **Comprehensive Coverage**: Covers all major API documentation requirements out of the box

#### Test Coverage

Added comprehensive test `testEnhancedOpenApiFeatures` that verifies:
- Auto-generated summaries match expected patterns
- Descriptions are contextually appropriate
- Multiple response codes are included (200, 400, 404, 500)
- Parameter descriptions and constraints are properly set
- POST operations use 201 status codes
- GET operations with path parameters include 404 responses

This enhancement transforms APISCAN from a basic endpoint scanner into a comprehensive API documentation generator that produces enterprise-ready OpenAPI specifications matching industry standards like those from major API providers.