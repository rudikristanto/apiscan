# APISCAN - API Endpoint Scanner

## Project Overview
**apiscan** is a CLI application that extracts API endpoints from various implementation types and generates OpenAPI documentation.

## Core Requirements

### Goal
- Create OpenAPI file in JSON or YAML format (✅ **ALWAYS GENERATED BY DEFAULT**)
- Output summary report - informative to users

### Critical Design Constraints
- **NO COMPILATION/BUILD REQUIRED**: The input project to be analyzed should NOT be built or compiled. Many enterprise projects cannot be compiled due to dependencies, configurations, or access restrictions. The tool MUST analyze source code as-is by reading files directly.
- CLI application
- Enterprise grade quality

### Design Considerations
- Extensible to analyze other frameworks (Quarkus, Struts) and languages (.NET Core)
- Testable architecture
- Easy to maintain
- Best performance
- AST-based implementation for accurate extraction

### MVP Scope
- Java-based API implementations
- Spring MVC support
- Spring Boot support

### Test Projects
- `C:\Users\Rudi Kristanto\prj\spring-petclinic-rest`
- `C:\Users\Rudi Kristanto\prj\shopizer`

## Development Guidelines
1. Always analyze source code without compilation
2. Use AST parsing for accurate endpoint extraction
3. Focus on extensibility for future framework support
4. Maintain clear separation between framework-specific analyzers

## Key Features

### Interface-Based Endpoint Detection
The Spring framework scanner supports multiple approaches for API endpoint detection:

1. **Direct Annotation Scanning**: Extracts endpoints from controller classes with Spring mapping annotations (`@GetMapping`, `@PostMapping`, etc.)

2. **Interface Implementation Analysis**: When controllers implement API interfaces (common in generated code or contract-first development), the scanner:
   - Collects all interfaces with Spring mapping annotations in a first pass
   - Matches controller classes that implement these interfaces
   - Extracts endpoint definitions from the interface methods

3. **Method Inference**: For cases where interface definitions are not available (external dependencies, generated code), the scanner can infer API endpoints from controller methods marked with `@Override`:
   - Analyzes method names to determine HTTP methods (`listOwners` → GET, `addOwner` → POST, `updateOwner` → PUT, `deleteOwner` → DELETE)
   - Constructs RESTful paths based on method names and parameters (`getOwner(Integer ownerId)` → `/owners/{ownerId}`)
   - Supports nested resource patterns (`addPetToOwner` → `/owners/{ownerId}/pets`)

### Test Results
- **spring-petclinic-rest**: Successfully detected 35 endpoints across 8 controllers
- **Before improvement**: 1 endpoint detected
- **After improvement**: 35 endpoints detected (35x improvement)

### Supported Patterns
- Standard REST controllers with direct annotations
- Interface-based API definitions (OpenAPI generated, contract-first)
- Mixed patterns within the same project
- Nested resource relationships (owners/pets/visits)
- All standard HTTP methods (GET, POST, PUT, DELETE, PATCH)

## Test Coverage

### Enterprise API Pattern Tests
1. **Direct Annotation-Based APIs**: Controllers with Spring mapping annotations
2. **Interface-Based APIs with Available Definitions**: Controllers implementing interfaces that contain Spring annotations
3. **Interface-Based APIs with Missing Definitions (@Override Inference)**: Controllers implementing external interfaces (JAR dependencies, generated code)
4. **Mixed Implementation Scenarios**: Projects combining both direct annotation and interface-based controllers
5. **Complex Nested Resource Hierarchies**: Multi-level REST resource relationships
6. **HTTP Method and Annotation Variations**: All Spring annotation types and parameter combinations
7. **CLI Integration Testing**: End-to-end command-line interface testing

### Test Scenarios Covering Enterprise Requirements
- **Legacy Enterprise Application**: Mixed annotations, complex domain models, multi-module Maven projects
- **Microservices Architecture**: Contract-first development, generated stubs, separate modules
- **Code Generation Workflows**: OpenAPI specification → Java code generation, missing interface source code
- **Migration Projects**: Gradual migration, mixed annotation styles, backward compatibility
- **Enterprise Integration**: Complex nested hierarchies, business entity relationships

### Test Execution and Quality Assurance
- **Maven Integration**: Tests run as part of build process (`mvn test`)
- **Java 17 Compatibility**: Modern language features with text blocks
- **Performance Testing**: Large project scanning (spring-petclinic-rest: 35 endpoints)
- **Error Handling**: Malformed code, missing dependencies, parsing failures
- **Output Validation**: Generated OpenAPI specifications, CLI reports

## Enhanced User Experience

### Professional CLI Output Formatting
Enterprise-grade console output with improved readability and professional presentation:

#### Key Improvements
1. **Professional Header Design**: Clean ASCII formatting and clear branding (Windows-compatible)
2. **Clean Progress Indicators**: Clear status messages without verbose debug output
3. **Structured Summary Reports**: Professionally formatted scan results with project information, performance metrics, HTTP method breakdown, controller organization, and detailed endpoint listing
4. **Enhanced Data Visualization**: HTTP method indicators [GET], [POST], [PUT], [DEL], [PATCH] with ASCII-safe formatting
5. **Reduced Debug Noise**: Production logging with clean console output and verbose mode available

### Cross-Platform Compatibility
- **ASCII-Safe Characters**: Replaced Unicode box-drawing and emoji with standard ASCII
- **Windows Console Support**: Fully compatible with Windows Command Prompt and PowerShell
- **Universal Display**: Consistent appearance across Windows, macOS, and Linux terminals

## OpenAPI File Generation

### Default Behavior
- **Automatic Generation**: OpenAPI files are **always generated** when scanning a project
- **Smart File Naming**: Auto-generates filename as `{project-name}-openapi.{format}` in current directory
- **Format Support**: YAML (default) and JSON formats available with `-f/--format` flag
- **User-Friendly**: No need to remember `-o/--output` parameter for basic usage

#### Example Usage
```bash
# Basic usage - generates spring-petclinic-rest-openapi.yaml in current directory
java -jar apiscan-cli.jar "C:\path\to\spring-petclinic-rest"

# Custom format - generates JSON instead of YAML
java -jar apiscan-cli.jar -f json "C:\path\to\spring-petclinic-rest"

# Custom location - saves to specific path
java -jar apiscan-cli.jar -o my-api-spec.yaml "C:\path\to\spring-petclinic-rest"
```

## DTO Schema Resolution and Generation

### Advanced DTO Support for Enterprise APIs
APISCAN includes sophisticated DTO (Data Transfer Object) schema resolution and generation, addressing a critical enterprise requirement: **handling generated code and complex data structures** in OpenAPI specifications.

#### Core DTO Functionality
- **Intelligent DTO Discovery**: Automatically searches for DTO classes in common locations (generated sources, build directories, source directories)
- **AST-Based Schema Parsing**: Analyzes DTO source code to extract field names, types, validation constraints, documentation, and collection types
- **OpenAPI 3.0.3 Compliant Output**: Generated schemas follow OpenAPI best practices with proper `$ref` references and detailed field type mapping

#### Enterprise DTO Patterns Supported
1. **Generated OpenAPI DTOs**: Complete support for Spring Boot OpenAPI code generation
2. **Dual DTO Pattern**: Handles read/write model separation common in enterprise APIs
3. **Missing DTO Graceful Handling**: When DTO source is unavailable, provides placeholder schemas
4. **Complex Nested Structures**: Supports enterprise entity relationships with collections and nested objects

### Multi-Module DTO Resolution
Enhanced support for enterprise Maven projects where model classes and API controllers are separated into different modules.

#### Solution Implemented
- **Multi-Module Search Strategy**: Enhanced `DtoSchemaResolver` to search across Maven project structures
- **Smart Module Recognition**: Uses heuristics to identify potential Maven modules (presence of `pom.xml`, standard Maven directory structure, module naming patterns)
- **Cross-Module Discovery**: Automatically finds DTOs regardless of module boundaries

#### Real-World Results
- **Shopizer E-commerce Platform**: 324 endpoints with complete DTO schema resolution
- **Schema Quality**: Rich object definitions with field types, arrays, and nested structures

### Recursive DTO Reference Resolution
Sophisticated recursive reference resolution ensures all DTO schemas referenced in the OpenAPI specification are properly included in the `components.schemas` section, preventing broken `$ref` links and validation errors.

## Enterprise OpenAPI Validation & Compliance

APISCAN includes comprehensive OpenAPI 3.0.3 specification compliance and validation fixes to ensure generated specifications pass semantic validation in enterprise tools and workflows.

### Critical OpenAPI Validation Issues Resolved
1. **Complex Path Parameter Extraction**: Enhanced path parameter extraction logic using regex patterns
2. **Schema Component Name Sanitization**: Implemented comprehensive schema name sanitization for invalid characters
3. **Unique OperationId Generation**: Implemented intelligent uniqueness detection with fallback strategies
4. **HTTP Method Request Body Validation**: Added method validation to prevent invalid request body inclusion
5. **Multiple Path Pattern Support**: Handles Spring annotations with multiple paths correctly

### Real-World Validation Results
**Shopizer E-commerce Platform (306 endpoints)**:
- **Before Fixes**: 68+ semantic validation errors
- **After Fixes**: ✅ Zero semantic validation errors, all endpoints pass validation

### Technical Implementation
**Key Components Enhanced**:
- `SwaggerCoreOpenApiGenerator`: Main compliance and validation logic
- `extractPathParameterNames()`: Regex-based complex path parameter extraction
- `sanitizeSchemaName()`: Comprehensive schema name normalization
- `ensureUniqueOperationId()`: Multi-strategy uniqueness enforcement
- `supportsRequestBody()`: HTTP method validation for request bodies

## Comprehensive HTTP Response Code Generation

### Enterprise-Grade Response Standards
APISCAN generates comprehensive HTTP response codes that match enterprise API documentation standards:

**Complete HTTP Status Code Coverage**:
- **200 OK**: Success responses with appropriate content types and schemas
- **201 Created**: For POST operations (resource creation)
- **304 Not Modified**: For GET and PUT operations (caching support)
- **400 Bad Request**: For malformed requests with error schema
- **404 Not Found**: For resource-specific operations with path parameters
- **500 Internal Server Error**: For server errors with error schema

**Smart Response Generation Logic**:
- Method-specific responses based on HTTP method
- Resource-aware error messages
- Conditional 304 support for cacheable operations
- Path parameter detection for 404 responses

## Enhanced Nested Object Schema Resolution

### Enterprise-Grade DTO Reference Generation
APISCAN generates proper schema references for nested DTO objects, eliminating empty object schemas and providing accurate example values in OpenAPI specifications.

#### Solution Implementation
- **Enhanced DTO Schema Resolver**: Intelligent nested object detection and reference generation
- **DTO Class Detection**: Identifies classes based on naming patterns (Dto, DTO, Response, Request, Entity, Model)
- **Proper Reference Generation**: Creates `$ref` schema references instead of empty objects
- **Collection Support**: Handles nested DTOs within collections

## OpenAPI Validation & Standards Compliance

### Critical Learning: Exact Parameter Name Matching Required
APISCAN uses **Swagger Core library** instead of custom OpenAPI generation to ensure full OpenAPI 3.0.3 specification compliance.

**OpenAPI Validation Rules**: Path parameters must have exact name matching between URL segments and parameter definitions.

#### Solution Implemented
1. **Extract Path Parameter Names**: Parse URL paths to identify all `{paramName}` segments
2. **Exact Matching**: Only treat parameters as path parameters if names match exactly
3. **Auto-Generate Missing Parameters**: Create path parameters for unmatched path segments
4. **Swagger Core Library**: Use industry-standard library instead of custom implementation

## Request Body Detection for Inferred Endpoints

### Enhanced DTO Parameter Recognition
APISCAN properly detects and includes request body parameters when inferring endpoints from @Override methods, addressing a critical gap in OpenAPI generation for interface-based controllers.

#### The Solution
Enhanced the SpringFrameworkScanner to intelligently identify DTO parameters as request bodies for POST/PUT/PATCH methods:
1. **Smart DTO Detection**: Recognizes common DTO patterns without requiring @RequestBody annotation
2. **HTTP Method Awareness**: Only treats DTO parameters as request bodies for modifying operations
3. **Backward Compatibility**: Continues to respect explicit @RequestBody annotations when present

## Professional Report Formatting with Aligned Indentation

### Enhanced Console Output Readability
APISCAN's report formatting provides professional, well-aligned output with consistent indentation throughout the entire report.

#### The Solution
1. **Consistent Column Widths**: Fixed-width formatting for HTTP methods, API paths, and method icons
2. **Professional Indentation**: Clear visual hierarchy between endpoints and their details
3. **Smart Truncation**: Handles long paths, parameter lists, and controller names gracefully
4. **Enhanced Visual Separators**: Section headers and consistent spacing

### Perfect Vertical URL Alignment Fix
Fixed the vertical alignment problem where endpoint URLs were not perfectly aligned due to inconsistent HTTP method icon widths:
1. **Fixed Method Icon Width**: Used consistent 8-character width for all method icons
2. **Removed Redundant Method Names**: Eliminated duplicate method information
3. **Adjusted Sub-item Indentation**: Updated Parameters and Request Body indentation to align perfectly under URLs

## Enhanced OpenAPI Generation with Enterprise-Grade Features

### Comprehensive OpenAPI 3.0.3 Specification Enhancement
APISCAN's OpenAPI generation produces enterprise-grade specifications that closely match industry standards.

#### Key Enhancements Implemented
1. **Auto-Generated Summaries and Descriptions**: Smart summary generation based on HTTP method and resource
2. **Enhanced Parameter Documentation**: Auto-generated parameter descriptions and type constraints
3. **Multiple HTTP Response Codes**: Success responses (200, 201) and error responses (400, 404, 500)
4. **Professional Response Content**: Proper content types and DTO schema references

#### Enterprise Benefits
1. **Professional Documentation**: Generated specifications suitable for external API documentation
2. **Tool Compatibility**: Works seamlessly with Swagger UI, Postman, ReDoc, and other OpenAPI tools
3. **Code Generation Ready**: Specifications can be used to generate client libraries and server stubs
4. **Industry Standard Compliance**: Follows OpenAPI 3.0.3 best practices and conventions
5. **Comprehensive Coverage**: Covers all major API documentation requirements out of the box

## Advanced Schema Generation Fixes

### @ApiIgnore Annotation Support
APISCAN now properly handles field exclusion annotations to prevent unwanted fields from appearing in OpenAPI specifications.

#### Supported Exclusion Annotations
- **@ApiIgnore**: Standard Swagger/OpenAPI field exclusion
- **@JsonIgnore**: Jackson JSON serialization exclusion
- **@Hidden**: Alternative OpenAPI field hiding annotation

#### Implementation Benefits
1. **Clean API Documentation**: Excludes internal/sensitive fields from public API documentation
2. **Framework Compatibility**: Supports multiple annotation frameworks (Swagger, Jackson, OpenAPI)
3. **Inheritance Support**: Properly handles excluded fields in class inheritance hierarchies

### Circular Reference Resolution
Enhanced DTO schema resolution prevents infinite loops and excessive nesting in complex entity relationships.

#### Key Improvements
1. **Reference-Based Schemas**: Uses `$ref` links instead of inline schema expansion
2. **Depth-Limited Resolution**: Configurable maximum resolution depth (default: 3 levels)
3. **Circular Reference Detection**: Prevents infinite recursion during schema resolution
4. **Proper Collection Handling**: Correctly identifies and handles `java.util.List`, `Set`, and `Collection` types

#### Real-World Impact
- **Before Fix**: Shopizer `reviews` and `attributes` fields generated 1000+ line nested schemas
- **After Fix**: Clean `$ref` references with controlled depth and proper schema separation

### Technical Implementation Details
1. **Enhanced DtoSchemaResolver**: 
   - `isApiIgnoredField()`: Multi-framework annotation detection
   - `getAllResolvedSchemas()`: Controlled recursive schema resolution
   - `findReferencedSchemas()`: Reference tracking and validation

2. **Improved SwaggerCoreOpenApiGenerator**:
   - Removed immediate recursive resolution to prevent circular references
   - Uses `getAllResolvedSchemas()` for final schema collection
   - Limited depth schema resolution (3 levels default)

### Test Coverage
- **ApiIgnoreSupportTest**: Validates @ApiIgnore, @JsonIgnore, @Hidden annotation handling
- **CircularReferenceFixTest**: Tests circular reference prevention and depth limiting
- **ShopizerComplexSchemaTest**: Tests complex nested schema scenarios similar to enterprise e-commerce platforms
- **Full Regression Testing**: All existing functionality preserved and enhanced

## Java Runtime Compatibility

### System Requirements
- **Minimum Java Version**: Java 17
- **Recommended Java Version**: Java 17 or later
- **Testing**: Tested with Java 17 and Java 21

### Runtime Environment Notes
- APISCAN is compiled with Java 17 target for optimal performance and modern language features
- Uses modern Java APIs including Files.readString(), Files.writeString(), Set.of(), Optional.isEmpty(), and String.repeat()
- For deployment environments with older Java versions, consider upgrading the runtime to Java 17+ for full compatibility

## Complex Schema Generation Enhancements

### Shopizer-Class Enterprise Schema Resolution
APISCAN has been enhanced to handle complex enterprise-grade schema hierarchies like those found in Shopizer e-commerce platform.

#### Key Improvements for Complex Schemas
1. **Increased Resolution Depth**: Default depth increased from 3 to 7 levels to handle deep nested enterprise entities
2. **Enhanced Reference Detection**: Improved findReferencedSchemas method to discover all schema references including allOf, oneOf, anyOf combinations
3. **Advanced Schema Name Sanitization**: Handles edge cases like generic types, arrays, and invalid OpenAPI component names
4. **Duplicate Field Prevention**: Eliminates duplicate required fields from inheritance hierarchies

#### Real-World Impact
- **Shopizer Before**: Multiple resolver errors with missing schema references (ProductPrice, ProductVariation, CustomerGender, etc.)
- **Shopizer After**: Clean schema resolution with proper $ref references and comprehensive component schema generation
- **Enterprise Scalability**: Handles complex multi-level entity relationships common in enterprise e-commerce platforms

#### Technical Enhancements
- **Consistent Schema Name Sanitization**: 
  - Converts problematic names like `?`, `byte[]`, and generic types to valid OpenAPI component names
  - Applied consistently across the entire schema generation pipeline (caching, resolution, and component generation)
  - Handles edge cases: `?` → `UnknownType`, `byte[]` → `ByteArray`, generic types stripped to base type
  - Ensures all schema references use sanitized names to prevent OpenAPI validation errors
- **Reference Resolution**: Comprehensive reference tracking across nested properties, array items, and schema compositions
- **Duplicate Prevention**: LinkedHashSet-based deduplication of required field lists
- **Performance Optimization**: Controlled depth limits prevent infinite recursion while allowing sufficient resolution depth

## Schema Name Validation & OpenAPI Compliance Fixes

### Critical Schema Name Sanitization Enhancement
APISCAN now provides comprehensive schema name sanitization to ensure full OpenAPI 3.0.3 specification compliance and eliminate semantic validation errors.

#### Problem Resolved
- **Before**: Invalid schema component names like `?` and `byte[]` caused semantic validation errors
- **After**: All schema names are properly sanitized to comply with OpenAPI naming requirements

#### Solution Implemented
1. **Consistent Sanitization Pipeline**: Schema names are sanitized at all points in the generation process:
   - During schema caching in `DtoSchemaResolver`
   - When creating schema references (`$ref` links)
   - Before adding schemas to OpenAPI components section

2. **Comprehensive Edge Case Handling**:
   ```java
   "?" → "UnknownType"
   "byte[]" → "ByteArray" 
   "List<String>" → "List" (generic types stripped)
   "com.example.ClassName" → "ClassName" (package names removed)
   ```

3. **OpenAPI Compliance**: All schema names now comply with OpenAPI component naming rules (A-Z a-z 0-9 - . _)

#### Real-World Impact
**Shopizer E-commerce Platform Results**:
- **Before**: Multiple semantic errors for invalid component names
- **After**: ✅ Zero semantic validation errors, 145 schemas with valid names
- **Enterprise Ready**: Generated specifications pass validation in tools like Swagger UI, Postman, and automated CI/CD pipelines

## DTO Schema Optimization & Field Filtering

### Improved DTO Schema Generation
APISCAN now includes sophisticated field filtering to ensure DTO schemas contain only appropriate business fields and exclude problematic internal Java fields.

#### Problem Resolved
- **Before**: DTO schemas included inappropriate fields like `DEFAULT_STRING_COLLATOR`, `serialVersionUID`, and other static/internal fields
- **After**: Clean DTO schemas with only business-relevant instance fields

#### Solution Implemented
**Smart Field Filtering with `shouldIncludeField()` method**:
1. **Static Field Exclusion**: Automatically excludes static fields that are not part of instance data
2. **Problematic Field Name Detection**: Filters out fields with names like:
   - `DEFAULT_STRING_COLLATOR` and other `DEFAULT_*` patterns
   - `serialVersionUID` (Java serialization field)  
   - Fields containing `COLLATOR` (internal Java utility fields)
3. **API Annotation Respect**: Continues to honor `@ApiIgnore`, `@JsonIgnore`, and `@Hidden` annotations
4. **Access-Based Filtering**: Only includes fields that are public or have getter methods

#### Real-World Impact
**Shopizer E-commerce Platform Results**:
- **PersistableCustomerAttribute**: Reduced from 5 to 4 properties (removed `DEFAULT_STRING_COLLATOR`)
- **PersistableCategory**: Reduced from 16 to 15 properties  
- **MerchantStore**: Reduced from 22 to 20 properties
- **AjaxResponse**: Reduced from 10 to 5 properties
- **Cleaner Schemas**: Generated OpenAPI specifications now contain only business-relevant fields

#### Technical Implementation
- **Enhanced Field Detection**: Modified both direct field parsing and inherited field parsing
- **Comprehensive Test Coverage**: Added `StaticFieldFilteringTest` to verify filtering behavior
- **Backward Compatibility**: All existing functionality preserved while improving schema quality

## Intelligent Package Resolution & DTO Prioritization

### Multi-Module DTO Package Prioritization
APISCAN now includes sophisticated package resolution that correctly prioritizes DTO layer classes over JPA entity classes in complex multi-module Maven projects.

#### Problem Resolved
- **Before**: When multiple classes with the same name existed (e.g., `CustomerOption` in both DTO and JPA layers), APISCAN would find the first match, often selecting complex JPA entities instead of simple DTO classes
- **After**: Intelligent prioritization selects appropriate DTO layer classes for OpenAPI documentation

#### Real-World Case Study: Shopizer E-commerce Platform
**Complex Multi-Module Structure**:
```
shopizer/
├── sm-shop/ (main application)
├── sm-shop-model/ (simple DTO classes) 
└── sm-core-model/ (complex JPA entities)
```

**Before**: 
- `CustomerOption`: 9 properties (complex JPA entity with merchantStore, descriptions, etc.)
- `CustomerOptionValue`: 6 properties (complex with images, descriptions, etc.)

**After**:
- `CustomerOption`: 1 property (`id` only - simple DTO)
- `CustomerOptionValue`: 1 property (`id` only - simple DTO)

#### Technical Implementation
**Enhanced Multi-Module Search with Prioritization**:
1. **Comprehensive Module Discovery**: Searches all potential Maven modules in project hierarchy
2. **Multi-Match Collection**: Collects ALL matches across ALL modules before prioritization
3. **Intelligent Package Prioritization**: Uses priority order:
   ```java
   // Highest Priority (DTO layers)
   "sm-shop-model", "shop.model", "api.model", "dto", "generated"
   
   // Lower Priority (JPA entity layers)  
   "sm-core-model", "core.model", "entity", "domain", "persistence"
   ```
4. **Debug Logging**: Provides clear visibility into selection process

#### Results
**CustomerOption and CustomerOptionValue Schemas**:
- ✅ **Simplified to single `id` property** (from 9 and 6 properties respectively)
- ✅ **Clean PersistableCustomerAttribute references** without bloated JPA entity fields
- ✅ **Enterprise API Documentation Quality** with appropriate abstraction levels

**Multi-Match Detection and Resolution**:
- Successfully prioritized **20+ different class conflicts** in Shopizer
- Automatic selection of DTO-appropriate versions across Categories, Products, Customers, and Attributes
- Maintained backward compatibility with single-module projects